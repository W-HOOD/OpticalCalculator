<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>WebGL Pixel Transform with Gridlines</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; }
  #container { position: relative; display: inline-block; }
  canvas { display: block; }
  #gridCanvas {
    position: absolute;
    top: 0; left: 0;
    pointer-events: none; /* let mouse events pass through */
  }
</style>
<style>
  #container {
    max-width: 90vw;
    max-height: 90vh;
  }
  canvas {
    width: 100%;  /* scale canvas visually */
    height: auto; /* maintain aspect ratio */
    display: block;
    max-width: 800px;
    max-height: 600px;
  }
</style>
</head>
<body>
  <h2>Upload Image - WebGL Pixel Transform with Gridlines</h2>
  <input type="file" id="fileInput" accept="image/*" />
  <div id="container">
    <canvas id="glCanvas"></canvas>
    <canvas id="gridCanvas"></canvas>
  </div>

<script>
// Vertex shader (pass-through)
const vertexShaderSource = `#version 300 es
in vec2 a_position;
in vec2 a_texCoord;
out vec2 v_texCoord;
void main() {
  gl_Position = vec4(a_position, 0, 1);
  v_texCoord = a_texCoord;
}
`;

// Fragment shader (demo transform: horizontal flip)
const fragmentShaderSource = `#version 300 es
precision mediump float;
in vec2 v_texCoord;
uniform sampler2D u_image;
out vec4 outColor;
void main() {
  // Flip horizontally as example transform
  vec2 uv = vec2(1.0 - v_texCoord.x, v_texCoord.y);
  outColor = texture(u_image, uv);
}
`;

// Compile shader helper
function compileShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader compile failed:', gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

// Create program helper
function createProgram(gl, vsSource, fsSource) {
  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vsSource);
  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);
  if (!vertexShader || !fragmentShader) return null;

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link failed:', gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
    return null;
  }
  return program;
}

// Draw gridlines on 2D canvas overlay
function drawGrid(ctx, width, height, gridSpacing = 20) {
  ctx.clearRect(0, 0, width, height);
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 1;
  ctx.font = "12px monospace";
  ctx.fillStyle = 'rgba(255,255,255,0.7)';

  // vertical lines and labels
  for(let x = 0; x <= width; x += gridSpacing) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, height);
    ctx.stroke();
    ctx.fillText(x, x + 2, 12);
  }

  // horizontal lines and labels
  for(let y = 0; y <= height; y += gridSpacing) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(width, y);
    ctx.stroke();
    ctx.fillText(y, 2, y - 2);
  }
}

async function main() {
  const fileInput = document.getElementById('fileInput');
  const glCanvas = document.getElementById('glCanvas');
  const gridCanvas = document.getElementById('gridCanvas');
  const container = document.getElementById('container');
  const gl = glCanvas.getContext('webgl2');
  if (!gl) {
    alert("WebGL2 not supported in this browser.");
    return;
  }

  const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
  if (!program) return;

  // Look up attribute/uniform locations
  const positionLoc = gl.getAttribLocation(program, 'a_position');
  const texCoordLoc = gl.getAttribLocation(program, 'a_texCoord');
  const imageLoc = gl.getUniformLocation(program, 'u_image');

  // Setup quad vertices and texture coords
  const positions = new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
    -1,  1,
     1, -1,
     1,  1,
  ]);
  const texCoords = new Float32Array([
    0, 1,
    1, 1,
    0, 0,
    0, 0,
    1, 1,
    1, 0,
  ]);

  // Create buffers
  const posBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

  const texBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

  // Create and bind texture
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  // Setup texture parameters to allow any size image
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

  function resizeCanvases(width, height) {
    glCanvas.width = width;
    glCanvas.height = height;
    gridCanvas.width = width;
    gridCanvas.height = height;
    container.style.width = width + 'px';
    container.style.height = height + 'px';
  }

  fileInput.addEventListener('change', async () => {
    const file = fileInput.files[0];
    if (!file) return;

    const img = new Image();
    img.onload = () => {
      resizeCanvases(img.width, img.height);

      // Upload image to texture
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);

      // Setup viewport
      gl.viewport(0, 0, glCanvas.width, glCanvas.height);

      // Clear canvas
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      // Use program
      gl.useProgram(program);

      // Enable attributes and bind buffers
      gl.enableVertexAttribArray(positionLoc);
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
      gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

      gl.enableVertexAttribArray(texCoordLoc);
      gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
      gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);

      // Bind texture unit 0 to u_image
      gl.uniform1i(imageLoc, 0);

      // Draw triangles
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Draw grid overlay
      const ctx = gridCanvas.getContext('2d');
      drawGrid(ctx, gridCanvas.width, gridCanvas.height, 50);
    };
    img.src = URL.createObjectURL(file);
  });
}

main();
</script>
</body>
</html>
